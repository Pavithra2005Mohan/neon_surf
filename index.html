<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Neon Surf - Amigos Club Prototype</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700;900&display=swap');

        body {
            margin: 0;
            overflow: hidden;
            background-color: #000;
            color: white;
            font-family: 'Orbitron', sans-serif;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            width: 100vw;
            touch-action: none; 
        }

        /* --- GAME CONTAINER & ANIMATIONS --- */
        @keyframes borderPulse {
            0% { box-shadow: 0 0 20px #00f2ff; border-color: #00f2ff; }
            50% { box-shadow: 0 0 40px #bc13fe; border-color: #bc13fe; }
            100% { box-shadow: 0 0 20px #00f2ff; border-color: #00f2ff; }
        }

        #gameWrapper {
            position: relative;
            width: 100%;
            height: 100%;
            display: flex;
            justify-content: center;
            align-items: center;
            background: #050510;
        }

        #gameContainer {
            position: relative;
            width: 800px;
            height: 450px;
            background: #000;
            border: 2px solid #00f2ff;
            box-shadow: 0 0 30px rgba(0, 242, 255, 0.2);
            animation: borderPulse 4s infinite;
            overflow: hidden;
            max-width: 100%;
            max-height: 100%;
        }

        canvas {
            display: block;
            width: 100%;
            height: 100%;
            transform: translateZ(0);
        }

        /* --- ROTATE DEVICE WARNING (Mobile Portrait) --- */
        #rotateWarning {
            display: none;
            position: fixed;
            top: 0; left: 0; width: 100%; height: 100%;
            background: #000;
            z-index: 100;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            text-align: center;
        }

        #rotateWarning h2 {
            color: #00f2ff;
            font-size: 24px;
            margin-bottom: 20px;
        }

        .rotate-icon {
            font-size: 50px;
            animation: rotateAnim 2s infinite;
        }

        @keyframes rotateAnim {
            0% { transform: rotate(0deg); }
            50% { transform: rotate(90deg); }
            100% { transform: rotate(0deg); }
        }

        /* --- CRT SCANLINE EFFECT --- */
        .scanlines {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(
                to bottom,
                rgba(255,255,255,0),
                rgba(255,255,255,0) 50%,
                rgba(0,0,0,0.1) 50%,
                rgba(0,0,0,0.1)
            );
            background-size: 100% 4px;
            pointer-events: none;
            z-index: 20;
        }

        .vignette {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: radial-gradient(circle, transparent 40%, rgba(0,0,0,0.9) 100%);
            pointer-events: none;
            z-index: 19;
        }

        /* --- UI OVERLAYS (GLASSMORPHISM) --- */
        .overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            background: rgba(5, 5, 16, 0.7);
            backdrop-filter: blur(8px);
            -webkit-backdrop-filter: blur(8px);
            z-index: 30;
            transition: opacity 0.3s, transform 0.3s;
        }

        .hidden {
            opacity: 0;
            pointer-events: none;
            transform: scale(1.1);
        }

        .panel {
            background: rgba(0, 0, 0, 0.6);
            border: 1px solid rgba(0, 242, 255, 0.3);
            padding: 40px;
            border-radius: 10px;
            box-shadow: 0 0 20px rgba(0, 0, 0, 0.5), inset 0 0 20px rgba(0, 242, 255, 0.1);
            text-align: center;
            max-width: 90%;
            position: relative;
        }
        
        .panel::before {
            content: ''; position: absolute; top: -1px; left: -1px;
            width: 20px; height: 20px; border-top: 2px solid #00f2ff; border-left: 2px solid #00f2ff;
        }
        .panel::after {
            content: ''; position: absolute; bottom: -1px; right: -1px;
            width: 20px; height: 20px; border-bottom: 2px solid #00f2ff; border-right: 2px solid #00f2ff;
        }

        h1 {
            font-size: 50px;
            margin: 0 0 15px 0;
            text-transform: uppercase;
            background: linear-gradient(to bottom, #fff, #00f2ff);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            text-shadow: 0 0 20px rgba(0, 242, 255, 0.6);
            letter-spacing: 4px;
        }

        p {
            font-size: 16px;
            color: #ccc;
            margin-bottom: 25px;
            line-height: 1.6;
            text-shadow: 0 2px 2px #000;
        }

        /* --- BUTTONS --- */
        button {
            padding: 15px 60px;
            font-size: 20px;
            font-family: 'Orbitron', sans-serif;
            font-weight: 900;
            color: #050510;
            background: #00f2ff;
            border: none;
            border-radius: 2px;
            cursor: pointer;
            box-shadow: 0 0 15px #00f2ff;
            transition: all 0.2s;
            text-transform: uppercase;
            letter-spacing: 2px;
            clip-path: polygon(10% 0, 100% 0, 100% 70%, 90% 100%, 0 100%, 0 30%);
            user-select: none; -webkit-user-select: none;
        }

        button:hover { background: #fff; box-shadow: 0 0 30px #fff; transform: translateY(-2px); }
        button:active { transform: translateY(1px); }

        /* --- CONTROLS HINTS --- */
        .controls-hint {
            display: flex;
            gap: 15px;
            margin-bottom: 25px;
            justify-content: center;
        }
        
        .key {
            border: 1px solid rgba(255,255,255,0.3);
            padding: 8px 12px;
            border-radius: 4px;
            color: #00f2ff;
            background: rgba(0,0,0,0.5);
            font-size: 12px;
            box-shadow: 0 2px 0 #00f2ff;
        }

        .mobile-hint {
            display: none;
            font-size: 14px;
            color: #00f2ff;
            margin-bottom: 20px;
            animation: pulse 2s infinite;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        @keyframes pulse { 0% { opacity: 0.6; } 50% { opacity: 1; } 100% { opacity: 0.6; } }

        /* --- IN-GAME HUD --- */
        #uiLayer {
            position: absolute;
            top: 0; left: 0; width: 100%; height: 100%;
            pointer-events: none; z-index: 15;
            display: flex; flex-direction: column;
            justify-content: space-between; padding: 20px; box-sizing: border-box;
        }

        .hud-top { display: flex; justify-content: space-between; align-items: flex-start; }

        .tech-stat-bar {
            display: flex; gap: 20px; background: rgba(0, 0, 0, 0.7);
            padding: 10px 20px; border-bottom: 2px solid #00f2ff;
            clip-path: polygon(0 0, 100% 0, 95% 100%, 5% 100%); backdrop-filter: blur(4px);
        }

        .stat-box { display: flex; flex-direction: column; align-items: center; min-width: 80px; }
        .stat-label { font-size: 10px; color: #00f2ff; letter-spacing: 1px; margin-bottom: 2px; text-transform: uppercase; }
        .stat-val { font-size: 24px; color: #fff; text-shadow: 0 0 10px #00f2ff; font-weight: 700; }
        .coin-text { color: #ffff00; text-shadow: 0 0 10px #ffff00; }

        .lives-container {
            display: flex; gap: 5px; background: rgba(0,0,0,0.5);
            padding: 5px 10px; border-radius: 20px; border: 1px solid rgba(255,255,255,0.1);
        }

        .heart { font-size: 22px; color: #ff0055; text-shadow: 0 0 10px #ff0055; }
        .heart.lost { color: #333; text-shadow: none; }
        
        .buff-row { display: flex; gap: 10px; margin-top: 10px; }
        .buff-icon {
            font-size: 18px; width: 35px; height: 35px; display: none; 
            align-items: center; justify-content: center; border-radius: 50%;
            background: rgba(0,0,0,0.8); border: 2px solid #fff; box-shadow: 0 0 10px currentColor;
        }

        /* Result Screen Stats */
        .result-row {
            display: flex; justify-content: center; gap: 40px;
            margin: 20px 0; padding: 20px; background: rgba(255,255,255,0.05); border-radius: 5px;
        }
        .result-item { text-align: center; }
        .result-label { color: #888; font-size: 12px; margin-bottom: 5px; text-transform: uppercase; }
        .result-val { font-size: 32px; font-weight: bold; }
        .high-score-label { margin-top: 15px; color: #666; font-size: 12px; letter-spacing: 1px; }

        /* MEDIA QUERY FOR MOBILE */
        @media (max-width: 820px) {
            #gameContainer {
                width: 100%; height: 100vh; border: none; box-shadow: none;
            }
            .panel { width: 90%; padding: 20px; }
            h1 { font-size: 36px; }
            p { font-size: 14px; margin-bottom: 15px; }
            .controls-hint { display: none; }
            .mobile-hint { display: block; }
            .tech-stat-bar { padding: 5px 15px; gap: 15px; }
            .stat-val { font-size: 20px; }
        }

        /* FORCE LANDSCAPE WARNING */
        @media screen and (orientation: portrait) and (max-width: 820px) {
            #rotateWarning { display: flex; }
            #gameContainer { display: none; }
        }
    </style>
</head>
<body>

    <div id="rotateWarning">
        <div class="rotate-icon">üì±</div>
        <h2>PLEASE ROTATE DEVICE</h2>
        <p>Landscape Mode Required</p>
    </div>

    <div id="gameWrapper">
        <div id="gameContainer">
            <canvas id="gameCanvas"></canvas>
            <div class="scanlines"></div>
            <div class="vignette"></div>
            
            <div id="uiLayer">
                <div class="hud-top">
                    <div class="lives-container">
                        <div class="heart">‚ô•</div>
                        <div class="heart">‚ô•</div>
                        <div class="heart">‚ô•</div>
                    </div>

                    <div class="tech-stat-bar">
                        <div class="stat-box">
                            <div class="stat-label">DIST</div>
                            <div id="distDisplay" class="stat-val">0m</div>
                        </div>
                        <div class="stat-box">
                            <div class="stat-label">CREDITS</div>
                            <div id="coinDisplay" class="stat-val coin-text">0</div>
                        </div>
                    </div>
                </div>

                <div class="buff-row">
                    <div id="shieldIcon" class="buff-icon" style="color:#00ffff; border-color:#00ffff">üõ°Ô∏è</div>
                    <div id="magnetIcon" class="buff-icon" style="color:#d000ff; border-color:#d000ff">üß≤</div>
                    <div id="multiIcon" class="buff-icon" style="color:#00ff00; border-color:#00ff00">‚úñÔ∏è</div>
                </div>
            </div>

            <!-- Start Screen -->
            <div id="startScreen" class="overlay">
                <div class="panel">
                    <h1 id="titleText">NEON SURF</h1>
                    <p>SURVIVE THE GRID. COLLECT DATA.</p>
                    
                    <div class="controls-hint">
                        <div class="key">‚Üë JUMP</div>
                        <div class="key">‚Üì SLIDE</div>
                        <div class="key">‚Üê ‚Üí MOVE</div>
                    </div>
                    
                    <div class="mobile-hint">
                        ‚á° SWIPE TO PLAY ‚á£
                    </div>

                    <button id="startBtn">INITIATE</button>
                    <div class="high-score-label" id="menuHighScore">RECORD: 0m</div>
                </div>
            </div>

            <!-- Game Over Screen -->
            <div id="gameOverScreen" class="overlay hidden">
                <div class="panel">
                    <h1 style="color: #ff0055; -webkit-text-fill-color: #ff0055; background: none; text-shadow: 0 0 20px #ff0055;">SYSTEM FAILURE</h1>
                    
                    <div class="result-row">
                        <div class="result-item">
                            <div class="result-label">DISTANCE RUN</div>
                            <div class="result-val" id="finalDist">0m</div>
                        </div>
                        <div class="result-item">
                            <div class="result-label">CREDITS</div>
                            <div class="result-val coin-text" id="finalCoins">0</div>
                        </div>
                    </div>

                    <button id="restartBtn">REBOOT</button>
                </div>
            </div>
        </div>
    </div>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d', { alpha: false }); 
        const gameContainer = document.getElementById('gameContainer');
        const startScreen = document.getElementById('startScreen');
        const gameOverScreen = document.getElementById('gameOverScreen');
        
        const distDisplay = document.getElementById('distDisplay');
        const coinDisplay = document.getElementById('coinDisplay');
        const livesContainer = document.querySelector('.lives-container');
        const shieldIcon = document.getElementById('shieldIcon');
        const magnetIcon = document.getElementById('magnetIcon');
        const multiIcon = document.getElementById('multiIcon');
        const menuHighScore = document.getElementById('menuHighScore');
        
        const startBtn = document.getElementById('startBtn');
        const restartBtn = document.getElementById('restartBtn');
        const finalDistSpan = document.getElementById('finalDist');
        const finalCoinsSpan = document.getElementById('finalCoins');

        // Configuration
        let WIDTH = 800;
        let HEIGHT = 450;
        
        function resize() {
            canvas.width = WIDTH;
            canvas.height = HEIGHT;
        }
        resize();

        // Game State
        let gameState = 'MENU';
        let distance = 0;
        let coinsCollected = 0;
        let speed = 0;
        const MAX_SPEED = 45; 
        let lives = 3;
        let frame = 0;
        let highScore = localStorage.getItem('neonSurfHighScore') || 0;
        menuHighScore.innerText = `RECORD: ${Math.floor(highScore)}m`;

        // Powerup States
        let hasShield = false;
        let magnetTimer = 0;
        let multiplierTimer = 0;
        let shakeTimer = 0;

        const LANES = [-1, 0, 1];
        const LANE_WIDTH = 120;
        let worldHue = 280; 
        
        // Player State
        let playerLane = 1;
        let targetLane = 1;
        let playerX = 0;
        let playerY = 0; 
        let playerScaleY = 1; 
        
        // Physics
        let yVelocity = 0;
        let gravity = 1.2;
        let jumpPower = -22;
        let isJumping = false;
        let isSliding = false;
        let slideTimer = 0;

        let objects = [];
        let particles = [];
        let floatingTexts = [];
        let backgroundStars = [];
        let gridOffset = 0;
        let nextSpawnZ = 2000;

        // Init Background Stars
        for(let i=0; i<40; i++) {
            backgroundStars.push({
                x: Math.random() * WIDTH,
                y: Math.random() * HEIGHT * 0.5,
                size: Math.random() * 2,
                speed: Math.random() * 0.5 + 0.1
            });
        }

        const AudioContext = window.AudioContext || window.webkitAudioContext;
        const audioCtx = new AudioContext();

        function playSound(type) {
            if (audioCtx.state === 'suspended') audioCtx.resume();
            const osc = audioCtx.createOscillator();
            const gain = audioCtx.createGain();
            osc.connect(gain);
            gain.connect(audioCtx.destination);
            const now = audioCtx.currentTime;

            if (type === 'coin') {
                osc.type = 'sine'; osc.frequency.setValueAtTime(1200, now);
                gain.gain.setValueAtTime(0.05, now); gain.gain.linearRampToValueAtTime(0, now + 0.08);
                osc.start(now); osc.stop(now + 0.08);
            } else if (type === 'move') {
                osc.type = 'triangle'; osc.frequency.setValueAtTime(300, now);
                gain.gain.setValueAtTime(0.05, now); gain.gain.linearRampToValueAtTime(0, now + 0.05);
                osc.start(now); osc.stop(now + 0.05);
            } else if (type === 'jump') {
                osc.type = 'sine'; osc.frequency.setValueAtTime(400, now); osc.frequency.linearRampToValueAtTime(600, now + 0.1);
                gain.gain.setValueAtTime(0.05, now); gain.gain.linearRampToValueAtTime(0, now + 0.1);
                osc.start(now); osc.stop(now + 0.1);
            } else if (type === 'powerup') {
                osc.type = 'square'; osc.frequency.setValueAtTime(400, now); osc.frequency.linearRampToValueAtTime(800, now + 0.3);
                gain.gain.setValueAtTime(0.05, now); gain.gain.linearRampToValueAtTime(0, now + 0.3);
                osc.start(now); osc.stop(now + 0.3);
            } else if (type === 'hit') {
                osc.type = 'sawtooth'; osc.frequency.setValueAtTime(100, now);
                gain.gain.setValueAtTime(0.2, now); gain.gain.linearRampToValueAtTime(0, now + 0.2);
                osc.start(now); osc.stop(now + 0.2);
            }
        }

        // --- CONTROLS ---
        function moveLeft() { if (targetLane > 0) { targetLane--; playSound('move'); } }
        function moveRight() { if (targetLane < 2) { targetLane++; playSound('move'); } }
        function jump() { 
            if (!isJumping && !isSliding) { 
                isJumping = true; yVelocity = jumpPower; playSound('jump'); 
                spawnParticles(WIDTH/2, HEIGHT - 100, '#fff', 5);
            } 
        }
        function slide() { 
            if (!isJumping && !isSliding) { 
                isSliding = true; slideTimer = 40; playSound('move'); 
            } 
        }

        document.addEventListener('keydown', (e) => {
            if(gameState !== 'PLAYING') return;
            if (e.key === 'ArrowLeft' || e.key === 'a') moveLeft();
            if (e.key === 'ArrowRight' || e.key === 'd') moveRight();
            if (e.key === 'ArrowUp' || e.key === 'w' || e.key === ' ') jump();
            if (e.key === 'ArrowDown' || e.key === 's') slide();
        });

        let touchStartX = 0, touchStartY = 0;
        document.addEventListener('touchstart', e => {
            touchStartX = e.changedTouches[0].screenX;
            touchStartY = e.changedTouches[0].screenY;
        }, {passive: false});

        document.addEventListener('touchend', e => {
            if(gameState !== 'PLAYING') return;
            let touchEndX = e.changedTouches[0].screenX;
            let touchEndY = e.changedTouches[0].screenY;
            let dx = touchEndX - touchStartX;
            let dy = touchEndY - touchStartY;
            if (Math.abs(dx) > Math.abs(dy)) {
                if (Math.abs(dx) > 30) { dx > 0 ? moveRight() : moveLeft(); }
            } else {
                if (Math.abs(dy) > 30) { dy > 0 ? slide() : jump(); }
            }
        }, {passive: false});

        // --- CLASSES ---
        class FloatingText {
            constructor(text, x, y, color) {
                this.text = text; this.x = x; this.y = y; this.color = color;
                this.life = 1.0; this.vy = -2; 
            }
            update() { this.y += this.vy; this.life -= 0.02; }
            draw(ctx) {
                ctx.globalAlpha = this.life; ctx.fillStyle = this.color; ctx.font = "bold 20px 'Orbitron'";
                ctx.fillText(this.text, this.x, this.y); ctx.globalAlpha = 1.0;
            }
        }

        class GameObject {
            constructor(type, zPos = 2000, assignedLane = null) {
                this.type = type; this.z = zPos; this.active = true;
                if (type === 'building') {
                    this.side = Math.random() > 0.5 ? -1 : 1; 
                    this.xOffset = (Math.random() * 8 + 4) * this.side; 
                    this.height = 200 + Math.random() * 400;
                    this.width = 100 + Math.random() * 150;
                    this.colorHue = Math.random() * 60 + (worldHue - 30); 
                    this.windows = Math.floor(Math.random() * 1000);
                } else {
                    this.lane = assignedLane !== null ? assignedLane : Math.floor(Math.random() * 3);
                    this.isFlying = false;
                    if(type === 'obstacle') {
                        this.isFlying = Math.random() > 0.5;
                        this.style = Math.floor(Math.random() * 2);
                    }
                    this.floatOffset = Math.random() * 100;
                }
            }
            update() {
                this.z -= speed;
                if (this.z < -200) this.active = false;
            }
        }

        function project(xLane, z) {
            const camHeight = 150;
            const horizonY = HEIGHT * 0.4;
            const dist = 300;
            const scale = dist / (dist + z);
            const screenX = (WIDTH / 2) + (xLane * LANE_WIDTH * 2.5 * scale);
            const screenY = horizonY + (camHeight * 2 * scale);
            return { x: screenX, y: screenY, scale: scale };
        }

        function initGame() {
            gameState = 'PLAYING';
            distance = 0; coinsCollected = 0; lives = 3; speed = 15;
            hasShield = false; magnetTimer = 0; multiplierTimer = 0; shakeTimer = 0;
            objects = []; particles = []; floatingTexts = [];
            playerLane = 1; targetLane = 1; playerX = 0; playerY = 0; yVelocity = 0;
            isJumping = false; isSliding = false; nextSpawnZ = 2000; worldHue = 280; 
            
            for(let i=0; i<40; i++) {
                let z = 500 + (i * 70); 
                objects.push(new GameObject('building', z));
            }

            updateUI();
            startScreen.classList.add('hidden');
            gameOverScreen.classList.add('hidden');
            animate();
        }

        function updateUI() {
            distDisplay.innerText = Math.floor(distance) + "m";
            coinDisplay.innerText = coinsCollected;
            
            const hearts = livesContainer.querySelectorAll('.heart');
            for(let i=0; i<3; i++) {
                if(i < lives) hearts[i].classList.remove('lost');
                else hearts[i].classList.add('lost');
            }

            shieldIcon.style.display = hasShield ? 'flex' : 'none';
            magnetIcon.style.display = magnetTimer > 0 ? 'flex' : 'none';
            multiIcon.style.display = multiplierTimer > 0 ? 'flex' : 'none';
        }

        function spawnParticles(x, y, color, count) {
            if(particles.length > 40) return;
            for(let i=0; i<count; i++) {
                particles.push({
                    x: x, y: y,
                    vx: (Math.random() - 0.5) * 15,
                    vy: (Math.random() - 0.5) * 15,
                    life: 1.0,
                    color: color
                });
            }
        }
        
        function spawnText(text, x, y, color) {
            floatingTexts.push(new FloatingText(text, x, y, color));
        }

        function animate() {
            if (gameState !== 'PLAYING') return;

            frame++;
            let mult = multiplierTimer > 0 ? 2 : 1;
            distance += (speed * 0.01) * mult; 
            if (speed < MAX_SPEED) speed += 0.005; 
            gridOffset = (gridOffset + speed) % 100;
            worldHue = (worldHue + 0.05) % 360;

            if (magnetTimer > 0) magnetTimer--;
            if (multiplierTimer > 0) multiplierTimer--;
            if (shakeTimer > 0) shakeTimer--;

            if (frame % 30 === 0) updateUI();

            // Physics
            const targetX = LANES[targetLane];
            playerX += (targetX - playerX) * 0.2;

            if (isJumping) {
                playerY += yVelocity; yVelocity += gravity;
                if (playerY >= 0) { playerY = 0; yVelocity = 0; isJumping = false; }
            }
            if (isSliding) {
                slideTimer--; playerScaleY = 0.5;
                if (slideTimer <= 0) { isSliding = false; playerScaleY = 1.0; }
            } else { playerScaleY = 1.0; }

            // Spawning
            nextSpawnZ -= speed;
            if (nextSpawnZ <= 2000) {
                let spawnType = Math.random();
                let chosenLane = Math.floor(Math.random() * 3);

                if (spawnType > 0.98) {
                     let pType = Math.random();
                     let pStr = 'shield';
                     if(pType > 0.66) pStr = 'magnet'; else if (pType > 0.33) pStr = 'multiplier';
                     objects.push(new GameObject(pStr, 2000, chosenLane));
                     nextSpawnZ = 2000 + 400;
                } else if (spawnType > 0.6) {
                    let numCoins = Math.floor(Math.random() * 4) + 3; 
                    for(let i=0; i<numCoins; i++) {
                        objects.push(new GameObject('coin', 2000 + (i * 150), chosenLane));
                    }
                    nextSpawnZ = 2000 + (numCoins * 150) + 300; 
                } else {
                    objects.push(new GameObject('obstacle', 2000, chosenLane));
                    nextSpawnZ = 2000 + 600; 
                }
            }
            if (frame % 4 === 0) objects.push(new GameObject('building'));

            // Draw
            ctx.save(); 
            if (shakeTimer > 0) {
                let dx = (Math.random() - 0.5) * 10;
                let dy = (Math.random() - 0.5) * 10;
                ctx.translate(dx, dy);
            }

            ctx.fillStyle = '#050510';
            ctx.fillRect(-20, -20, WIDTH+40, HEIGHT+40);

            let sunY = HEIGHT * 0.35;
            let sunSize = 60;
            let mainColor = `hsl(${worldHue}, 100%, 50%)`;
            let compColor = `hsl(${worldHue + 180}, 100%, 50%)`;

            let g = ctx.createRadialGradient(WIDTH/2, sunY, sunSize*0.2, WIDTH/2, sunY, sunSize*1.5);
            g.addColorStop(0, '#fff'); g.addColorStop(0.2, mainColor); g.addColorStop(1, 'rgba(0,0,0,0)');
            ctx.fillStyle = g;
            ctx.beginPath(); ctx.arc(WIDTH/2, sunY, sunSize*1.5, 0, Math.PI*2); ctx.fill();

            ctx.fillStyle = '#050510';
            for(let i=0; i<10; i++) {
                let y = sunY - sunSize/2 + (i * 12);
                if (y > sunY + 10) ctx.fillRect(WIDTH/2 - sunSize, y, sunSize*2, 4);
            }

            ctx.fillStyle = '#fff';
            backgroundStars.forEach(star => {
                let starSpeed = star.speed * (speed / 10);
                star.x = (star.x - starSpeed) % WIDTH;
                if(star.x < 0) star.x = WIDTH;
                ctx.globalAlpha = Math.random() * 0.5 + 0.3;
                if (speed > 30) ctx.fillRect(star.x, star.y, star.size * 4, star.size); 
                else ctx.fillRect(star.x, star.y, star.size, star.size);
            });
            ctx.globalAlpha = 1.0;

            ctx.strokeStyle = mainColor;
            ctx.lineWidth = 1;
            ctx.globalAlpha = 0.3; 
            for (let i = -8; i <= 8; i++) {
                if (i > -2 && i < 2) continue; 
                let p1 = project(i, 0); let p2 = project(i, 2000);
                ctx.beginPath(); ctx.moveTo(p1.x, p1.y); ctx.lineTo(p2.x, p2.y); ctx.stroke();
            }
            for (let z = 0; z < 2000; z += 100) {
                let actualZ = z - gridOffset;
                if (actualZ < 0) actualZ += 2000;
                let pLeft = project(-10, actualZ); let pRight = project(10, actualZ); 
                ctx.beginPath(); ctx.moveTo(pLeft.x, pLeft.y); ctx.lineTo(pRight.x, pRight.y); ctx.stroke();
            }
            ctx.globalAlpha = 1.0;

            for (let i = objects.length - 1; i >= 0; i--) {
                let obj = objects[i];
                obj.update();
                if (!obj.active) { objects.splice(i, 1); continue; }

                let visualOffset = 0;
                if (magnetTimer > 0 && obj.type === 'coin' && obj.z < 600) {
                    let pullFactor = (600 - obj.z) / 600; 
                    let diff = playerLane - obj.lane;
                    visualOffset = diff * pullFactor * 0.8; 
                }

                let xParam = (obj.type === 'building') ? obj.xOffset : LANES[obj.lane] + visualOffset;
                let pos = project(xParam, obj.z);
                let size = 110 * pos.scale;

                let fogAlpha = 1.0;
                if (obj.z > 1000) fogAlpha = 1.0 - ((obj.z - 1000) / 1000);
                if (fogAlpha < 0) fogAlpha = 0;
                ctx.globalAlpha = fogAlpha;

                if (obj.type === 'building') {
                    let bW = obj.width * pos.scale; let bH = obj.height * 2 * pos.scale; 
                    let bX = pos.x - bW/2; let bY = pos.y - bH; 
                    ctx.fillStyle = '#080818'; ctx.strokeStyle = `hsl(${obj.colorHue}, 100%, 50%)`; ctx.lineWidth = 2;
                    ctx.fillRect(bX, bY, bW, bH); ctx.strokeRect(bX, bY, bW, bH);
                    ctx.fillStyle = `hsl(${obj.colorHue}, 100%, 70%)`;
                    if (pos.scale > 0.2) { 
                        for(let w=0; w<5; w++) {
                            let wy = bY + (w * bH/6) + 10;
                            if (obj.windows % (w+2) === 0) ctx.fillRect(bX + 5, wy, bW - 10, bH/10);
                        }
                    }
                } else if (obj.type === 'obstacle') {
                    let drawX = pos.x - size/2; let drawY = pos.y - size; 
                    if (obj.isFlying) {
                        let floatY = Math.sin((frame + obj.floatOffset) * 0.1) * 20;
                        drawY -= (size * 0.8) + floatY; 
                        if (obj.style === 1) { // Police
                            ctx.fillStyle = '#111'; ctx.strokeStyle = '#00f2ff'; ctx.lineWidth = 2;
                            ctx.beginPath(); ctx.moveTo(drawX, drawY + size*0.5); ctx.lineTo(drawX + size*0.2, drawY); 
                            ctx.lineTo(drawX + size*0.8, drawY); ctx.lineTo(drawX + size, drawY + size*0.6); 
                            ctx.lineTo(drawX + size*0.6, drawY + size*0.8); ctx.lineTo(drawX + size*0.2, drawY + size*0.8); 
                            ctx.closePath(); ctx.fill(); ctx.stroke();
                            if (frame % 10 < 5) { ctx.fillStyle = '#ff0000'; ctx.fillRect(drawX + size*0.3, drawY - size*0.2, size*0.1, size*0.2); } 
                            else { ctx.fillStyle = '#0000ff'; ctx.fillRect(drawX + size*0.5, drawY - size*0.2, size*0.1, size*0.2); }
                        } else { // Drone
                            ctx.fillStyle = 'rgba(255, 0, 0, 0.4)'; ctx.strokeStyle = '#ff0055'; ctx.lineWidth = 3;
                            ctx.beginPath(); ctx.moveTo(drawX + size*0.5, drawY); ctx.lineTo(drawX + size, drawY + size*0.3);
                            ctx.lineTo(drawX + size, drawY + size*0.7); ctx.lineTo(drawX + size*0.5, drawY + size);
                            ctx.lineTo(drawX, drawY + size*0.7); ctx.lineTo(drawX, drawY + size*0.3); ctx.closePath(); ctx.fill(); ctx.stroke();
                            ctx.strokeStyle = 'rgba(255,0,85,0.4)'; ctx.beginPath(); ctx.moveTo(drawX + size*0.5, drawY + size); ctx.lineTo(drawX + size*0.5, pos.y); ctx.stroke();
                        }
                    } else { // Ground
                        if (obj.style === 1) { // Car
                            ctx.fillStyle = '#222'; ctx.strokeStyle = '#ffff00'; ctx.lineWidth = 2;
                            ctx.fillRect(drawX, drawY + size*0.4, size, size*0.6); ctx.strokeRect(drawX, drawY + size*0.4, size, size*0.6);
                            ctx.fillStyle = '#00ffff'; ctx.beginPath(); ctx.moveTo(drawX + size*0.1, drawY + size*0.4); ctx.lineTo(drawX + size*0.2, drawY);
                            ctx.lineTo(drawX + size*0.8, drawY); ctx.lineTo(drawX + size*0.9, drawY + size*0.4); ctx.closePath(); ctx.fill();
                            ctx.fillStyle = '#fff'; ctx.beginPath(); ctx.arc(drawX + size*0.15, drawY + size*0.6, size*0.1, 0, Math.PI*2);
                            ctx.arc(drawX + size*0.85, drawY + size*0.6, size*0.1, 0, Math.PI*2); ctx.fill();
                        } else { // Block
                            ctx.fillStyle = `${mainColor.replace('50%', '20%').replace(')', ', 0.4)')}`; ctx.strokeStyle = mainColor; ctx.lineWidth = 3;
                            ctx.fillRect(drawX, drawY, size, size); ctx.strokeRect(drawX, drawY, size, size);
                            ctx.fillStyle = mainColor; ctx.fillRect(drawX + 10, drawY + 10, size - 20, 5); ctx.fillRect(drawX + 10, drawY + size - 15, size - 20, 5);
                        }
                    }
                } else if (obj.type === 'coin') {
                    let drawX = pos.x; let drawY = pos.y - size/2;
                    if (obj.isFlying) drawY -= size; 
                    ctx.beginPath(); ctx.arc(drawX, drawY, size/3, 0, Math.PI * 2); ctx.fillStyle = '#ffff00'; ctx.fill();
                    ctx.fillStyle = '#fff'; ctx.beginPath(); ctx.arc(drawX - size/10, drawY - size/10, size/10, 0, Math.PI * 2); ctx.fill();
                } else if (obj.type === 'shield' || obj.type === 'magnet' || obj.type === 'multiplier') {
                    let drawX = pos.x; let drawY = pos.y - size/2;
                    let pulse = Math.sin(frame * 0.2) * 5;
                    let pColor = '#fff'; let char = '?';
                    if(obj.type === 'shield') { pColor = '#00ffff'; char = 'S'; }
                    if(obj.type === 'magnet') { pColor = '#d000ff'; char = 'M'; }
                    if(obj.type === 'multiplier') { pColor = '#00ff00'; char = 'X'; }
                    ctx.beginPath(); ctx.arc(drawX, drawY, size/3 + pulse, 0, Math.PI * 2); ctx.fillStyle = pColor; ctx.fill();
                    ctx.fillStyle = '#000'; ctx.font = `bold ${size/3}px Arial`; ctx.textAlign = 'center'; ctx.textBaseline = 'middle'; ctx.fillText(char, drawX, drawY);
                }
                ctx.globalAlpha = 1.0; 

                // Collision
                if (obj.type !== 'building' && obj.active && obj.z < 60 && obj.z > -60) {
                    let isMagneticGrab = (magnetTimer > 0 && obj.type === 'coin');
                    if (obj.lane === targetLane || isMagneticGrab) {
                        let hit = false;
                        if (obj.type === 'coin') {
                            hit = true; coinsCollected += 1 * mult; playSound('coin');
                            spawnParticles(WIDTH/2, HEIGHT - 80, '#ffff00', 5);
                            spawnText(`+${10*mult}`, WIDTH/2, HEIGHT/2, '#ffff00');
                            obj.active = false; updateUI(); 
                        } else if (obj.type === 'shield') {
                            hit = true; hasShield = true; playSound('powerup');
                            spawnParticles(WIDTH/2, HEIGHT - 80, '#00ffff', 20); spawnText("SHIELD!", WIDTH/2, HEIGHT/2 - 50, '#00ffff');
                            obj.active = false; updateUI();
                        } else if (obj.type === 'magnet') {
                            hit = true; magnetTimer = 600; playSound('powerup');
                            spawnParticles(WIDTH/2, HEIGHT - 80, '#d000ff', 20); spawnText("MAGNET!", WIDTH/2, HEIGHT/2 - 50, '#d000ff');
                            obj.active = false; updateUI();
                        } else if (obj.type === 'multiplier') {
                            hit = true; multiplierTimer = 600; playSound('powerup');
                            spawnParticles(WIDTH/2, HEIGHT - 80, '#00ff00', 20); spawnText("2X SCORE!", WIDTH/2, HEIGHT/2 - 50, '#00ff00');
                            obj.active = false; updateUI();
                        } else {
                            if (obj.isFlying) { if (!isSliding) hit = true; } else { if (!isJumping) hit = true; }
                            if (hit) {
                                shakeTimer = 20; 
                                if (hasShield) {
                                    hasShield = false; playSound('powerup'); 
                                    spawnParticles(WIDTH/2, HEIGHT - 80, '#00ffff', 15); spawnText("BLOCKED!", WIDTH/2, HEIGHT/2, '#fff');
                                    obj.active = false; updateUI();
                                } else {
                                    lives--; playSound('hit');
                                    spawnParticles(WIDTH/2, HEIGHT - 80, '#ff0055', 15); obj.active = false; updateUI();
                                    if(lives <= 0) {
                                        gameState = 'GAMEOVER';
                                        finalDistSpan.innerText = Math.floor(distance) + "m";
                                        finalCoinsSpan.innerText = coinsCollected;
                                        if (distance > highScore) {
                                            highScore = distance;
                                            localStorage.setItem('neonSurfHighScore', highScore);
                                            menuHighScore.innerText = `RECORD: ${Math.floor(highScore)}m`;
                                        }
                                        gameOverScreen.classList.remove('hidden');
                                    }
                                }
                            }
                        }
                    }
                }
            }

            // Player Draw
            let playerPos = project(playerX, 0); let pSize = 70 * playerPos.scale;
            ctx.save();
            let visualY = playerPos.y - (pSize * 0.5) + playerY;
            if (!isJumping) visualY += Math.sin(frame * 0.2) * 5;
            ctx.translate(playerPos.x, visualY);
            let tilt = (playerX - LANES[targetLane]) * -0.3;
            ctx.rotate(tilt); ctx.scale(1, playerScaleY);

            if (hasShield) {
                ctx.strokeStyle = `rgba(0, 255, 255, ${Math.abs(Math.sin(frame * 0.1)) + 0.5})`; ctx.lineWidth = 4;
                ctx.beginPath(); ctx.arc(0, 0, pSize * 0.8, 0, Math.PI*2); ctx.stroke();
            }
            if (magnetTimer > 0) {
                ctx.strokeStyle = `rgba(208, 0, 255, 0.5)`; ctx.lineWidth = 2;
                ctx.beginPath(); ctx.arc(0, 0, pSize * 1.2 + Math.sin(frame*0.5)*10, 0, Math.PI*2); ctx.stroke();
            }

            ctx.fillStyle = '#0f0f22'; ctx.strokeStyle = mainColor; ctx.lineWidth = 3;
            ctx.beginPath(); ctx.arc(0, 0, pSize/2, 0, Math.PI*2); ctx.fill(); ctx.stroke();
            ctx.fillStyle = compColor; ctx.beginPath(); ctx.ellipse(0, -pSize/10, pSize/2.5, pSize/5, 0, 0, Math.PI*2); ctx.fill();
            if (isSliding) { if(frame % 3 === 0) spawnParticles(playerPos.x, playerPos.y, mainColor, 1); } 
            else { ctx.fillStyle = mainColor; ctx.beginPath(); ctx.moveTo(-pSize/4, pSize/2); ctx.lineTo(pSize/4, pSize/2); ctx.lineTo(0, pSize); ctx.fill(); }
            ctx.restore();

            for(let i=floatingTexts.length-1; i>=0; i--) {
                let ft = floatingTexts[i]; ft.update(); ft.draw(ctx);
                if(ft.life <= 0) floatingTexts.splice(i, 1);
            }
            if (particles.length > 50) particles.shift(); 
            for (let i = particles.length - 1; i >= 0; i--) {
                let p = particles[i]; p.x += p.vx; p.y += p.vy; p.life -= 0.1; 
                ctx.fillStyle = p.color; ctx.globalAlpha = p.life; ctx.fillRect(p.x, p.y, 4, 4);
                if(p.life <= 0) particles.splice(i, 1);
            }
            ctx.globalAlpha = 1.0;
            ctx.restore(); 

            if (gameState === 'PLAYING') { requestAnimationFrame(animate); }
        }

        startBtn.addEventListener('click', initGame);
        restartBtn.addEventListener('click', initGame);
        startBtn.addEventListener('touchend', (e) => { e.preventDefault(); initGame(); });
        restartBtn.addEventListener('touchend', (e) => { e.preventDefault(); initGame(); });
    </script>
</body>
</html>
